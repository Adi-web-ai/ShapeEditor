


<!DOCTYPE html>
<html lang="he">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google-site-verification" content="piSmbBGKAUaYGGzsSzF8xU8wCMAxMmrcB5WpgQrAuqo" />
    <title>爪专 砖专转 驻 注 Leaflet</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.4.0/axios.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://rawgit.com/mapbox/leaflet-image/gh-pages/leaflet-image.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dom-to-image-more/3.0.0/dom-to-image-more.min.js"></script>
    
    <link rel="stylesheet" href="dist/Leaflet.BigImage.min.css">
    <script src="dist/Leaflet.BigImage.min.js"></script>
    <style>
        #map { height: 690px; width:800px;}
    </style>
</head>
<body>
    <label for="colorPicker">专 爪注:</label>
    <input type="color" id="colorPicker" value="#ff0000">
    <label for="valueInput"> 注专:</label>
    <input type="text" id="valueInput" placeholder="住 注专">
    <button onclick="downloadPolygons()"> 砖专转 驻</button>
    <button onclick="downloadBuildingsData()"> 专转 转 </button>
    <button onclick="downloadPolygonsToExcel()"> 专转 驻 拽住</button>
    <button onclick="loadNextExcel()"> Next Excel</button>
    <input type="file" id="fileInput" accept=".*json" onchange="loadPolygons(event)">
    <label for="myCheck">Color:</label> 
	<input type="checkbox" id="myCheck" onclick="myFunction()">
    <input type="file" id="excelInput" accept=".xlsx" onchange="loadExcel()" multiple>
    <div id="mainContainer" style="display: flex; flex-direction: row; align-items: flex-start;">
    <div id="mainContainer" style="display: flex; flex-direction: row; align-items: flex-start;">
        <div id="map" style="height: 690px; width: 800px; margin-left: 20px;"></div>
    
        <div style="display: flex; gap: 40px; margin: 20px;">
            <!-- 转 注专 -->
            <div>
                <h3>转 注专</h3>
                <table id="valuesTable" border="1" style="border-collapse: collapse; width: 300px;">
                    <thead>
                        <tr><th>NUM</th><th>MIKRA</th></tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        
            <!-- 转 驻 -->
            <div>
                <h3>转 驻</h3>
                <table id="polygonTable" border="1" style="border-collapse: collapse; width: 300px;">
                    <thead>
                        <tr><th>ID</th><th>VALUE</th></tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
        
        </div>
    
    
        
    
    <script>
        var map = L.map('map').setView([32.0853, 34.7818], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
        var drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);
        var drawControl = new L.Control.Draw({
            edit: { featureGroup: drawnItems },
            draw: { polyline: true, polygon: true, rectangle: true, circle: true, marker: true }
        });
        map.addControl(drawControl);
        
        var colorMap = ["#FF0000", "#FF7F00", "#FFFF00", "#7FFF00", "#00FF00", "#00FF7F", "#00FFFF", "#007FFF", "#0000FF", "#7F00FF"];
        var polygonCounter = 0;

        map.on('draw:created', function (event) {
            var layer = event.layer;
            var color = document.getElementById("colorPicker").value;
            var value = document.getElementById("valueInput").value || "";
            var polygonID = ++polygonCounter;
            
            if(map.control){console.log("marker");}
            layer.setStyle({ color: color, fillColor: color, fillOpacity: 0.5 });
            if (!layer.feature) layer.feature = { type: "Feature", properties: {} };
            layer.feature.properties.color = color;
            layer.feature.properties.id = polygonID;
            layer.feature.properties.value = value;

            drawnItems.addLayer(layer);
        });
        function updateValuesTable(data) {
    const valuesTableBody = document.querySelector("#valuesTable tbody");
    const polygonTableBody = document.querySelector("#polygonTable tbody");
    valuesTableBody.innerHTML = "";
    polygonTableBody.innerHTML = "";

    const seenNums = new Set();
    const seenIDs = new Set();

    data.forEach(row => {
        // 转 注专 (NUM + MIKRA)
        if (row.NUM != null && row.MIKRA != null && !seenNums.has(row.NUM)) {
            seenNums.add(row.NUM);
            const tr = document.createElement("tr");

            const tdNum = document.createElement("td");
            tdNum.textContent = row.NUM;
            tdNum.style.backgroundColor = colorMap[row.NUM - 1] || "#000";
            tdNum.style.color = "#fff";
            tdNum.style.textAlign = "center";

            const tdMikra = document.createElement("td");
            tdMikra.textContent = row.MIKRA;

            tr.appendChild(tdNum);
            tr.appendChild(tdMikra);
            valuesTableBody.appendChild(tr);
        }

        // 转 驻 (ID + VALUE)
        if (row.ID != null && row.VALUE != null && !seenIDs.has(row.ID)) {
            seenIDs.add(row.ID);
            const tr = document.createElement("tr");
            tr.style.cursor = "pointer";

            const tdID = document.createElement("td");
            tdID.textContent = row.ID;
            tdID.style.backgroundColor = colorMap[row.NUM - 1] || "#000";
            tdID.style.color = "#fff";
            tdID.style.textAlign = "center";

            const tdValue = document.createElement("td");
            tdValue.textContent = row.VALUE;

            tr.appendChild(tdID);
            tr.appendChild(tdValue);

            tr.addEventListener("click", () => {
                drawnItems.eachLayer(layer => {
                    if (layer.feature && layer.feature.properties.oid_ezor == row.ID) {
                        map.fitBounds(layer.getBounds(), { maxZoom: 17 });
                    }
                });
            });

            polygonTableBody.appendChild(tr);
        }
    });
}



function downloadPolygons() {
    var geojson = drawnItems.toGeoJSON();
    console.log("geojson " + geojson)
    var blob = new Blob([JSON.stringify(geojson, null, 2)], { type: "application/json" });
    var a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "polygons.json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}
function ColorTransperent()
{
  let checkBox = document.getElementById("myCheck");
  
  if (checkBox.checked == true){
    return 'true';
  } else {
     return 'false';
  }
}
let polyFile ;
function restorePolygons()
{
    drawnItems.layerremove;
    drawnItems.eachLayer(layer => {layer.remove();})
    var file =structuredClone(polyFile); 
    if (!file) return;
    var reader = new FileReader();
    reader.onload = function (e) {
        var geojson = JSON.parse(e.target.result);
        console.log("drawnItems " + drawnItems + " " + geojson);
        L.geoJSON(geojson, {
            style: function (feature) {
                if(ColorTransperent() == 'true') 
                {
                return { color: feature.properties.color, fillColor: feature.properties.color, fillOpacity: 0.3 };
                }else{
                return { color: "#FF0000", fillColor: "#00000000" };
                }
                
                //return { color: feature.properties.color, fillColor: feature.properties.color, fillOpacity: 0.5 };
                //   return { color: "#FF0000", fillColor: "#00000000" };
                
            },
            onEachFeature: function (feature, layer) {
                drawnItems.addLayer(layer);
            }
            
        }).addTo(drawnItems);
    };
    
    reader.readAsText(file);
}
function loadPolygons(event) {
    
    var file = event.target.files[0];
    polyFile =structuredClone(file);// file;
    if (!file) return;
    var reader = new FileReader();
    reader.onload = function (e) {
        var geojson = JSON.parse(e.target.result);
        console.log("drawnItems " + drawnItems + " " + geojson);
        L.geoJSON(geojson, {
            style: function (feature) {
                if(ColorTransperent() == 'true') 
                {
                return { color: feature.properties.color, fillColor: feature.properties.color, fillOpacity: 0.3 };
                }else{
                return { color: "#FF0000", fillColor: "#00000000" };
                }
                
                //return { color: feature.properties.color, fillColor: feature.properties.color, fillOpacity: 0.5 };
                //   return { color: "#FF0000", fillColor: "#00000000" };
                
            },
            onEachFeature: function (feature, layer) {
                drawnItems.addLayer(layer);
            }
            
        }).addTo(drawnItems);
    };
    
    reader.readAsText(file);
}
//drawnItems.eachLayer(layer => { layer.bindPopup( 'layer.value' ); });
//.bindPopup(popupContent).openPopup();
//var file = document.getElementById("excelInput").files[0];
let files = [] ;
let fileCounter = 0;
function loadNextExcel() {
    if (!polyFile || files.length === 0) {
        alert("住专 拽抓 JSON  拽抓 Excel");
        return;
    }

    if (fileCounter >= files.length) {
        fileCounter = 0;
    }

    clearMapLayers(); // 拽转  砖转 拽转

    // 砖 1: 注 转 驻 砖 -JSON
    var readerJson = new FileReader();
    readerJson.onload = function (e) {
        var geojson = JSON.parse(e.target.result);

        // 砖 2: 注 转 拽抓 拽住  驻 拽专
        var excelFile = structuredClone(files[fileCounter]);
        var readerExcel = new FileReader();
        readerExcel.onload = function (ev) {
            var data = new Uint8Array(ev.target.result);
            var workbook = XLSX.read(data, { type: 'array' });
            var sheet = workbook.Sheets[workbook.SheetNames[0]];
            var excelData = XLSX.utils.sheet_to_json(sheet);
            updateValuesTable(structuredClone(excelData));
            // 砖 3: 专 砖 Excel 驻 ID 爪注
            var colorMapById = {};
            excelData.forEach(row => {
                if (row.ID != null) {
                    colorMapById[row.ID] = {
                        color: colorMap[row.NUM - 1] || "#000000",
                        value: row.VALUE,
                        mikra: row.MIKRA
                    };
                }
            });
            

            // 砖 4: 住驻转 砖转 驻 注 爪注
            L.geoJSON(geojson, {
                style: function (feature) {
                    var id = feature.properties.oid_ezor;
                    if (colorMapById[id]) {
                        return {
                            color: colorMapById[id].color,
                            fillColor: colorMapById[id].color,
                            fillOpacity: 0.5,
                            mikra:colorMapById[id].mikra
                        };
                    } else {
                        return {
                            color: "#FF0000",
                            fillColor: "#00000000",
                            fillOpacity: 0.1
                        };
                    }
                },
                onEachFeature: function (feature, layer) {
                    var id = feature.properties.oid_ezor;
                    if (colorMapById[id]) {
                        feature.properties.color = colorMapById[id].color;
                        feature.properties.value = colorMapById[id].value;
                        feature.properties.mikra = colorMapById[id].mikra;
                       // feature.properties.ms_ezor = colorMapById[id].value;
                      //  layer.value = colorMapById[id].color;
                        
                      //  layer.value = colorMapById[id].value;
                    }
                    drawnItems.addLayer(layer);
                }
            });
        };
        readerExcel.readAsArrayBuffer(excelFile);
        fileCounter++;
    };

    readerJson.readAsText(structuredClone(polyFile));
    
}

function clearMapLayers() {
    drawnItems.clearLayers();
}

function loadExcel() {
    
    files = document.getElementById("excelInput").files;
    var file =structuredClone(files[0]) ;
    if (!file) return;
    var reader = new FileReader();
    reader.onload = function (e) {
        var data = new Uint8Array(e.target.result);
        var workbook = XLSX.read(data, { type: 'array' });
        var sheet = workbook.Sheets[workbook.SheetNames[0]];
        var json = XLSX.utils.sheet_to_json(sheet);
        updateValuesTable(structuredClone(json));
        json.forEach(row => {
            drawnItems.eachLayer(layer => {
                if (layer.feature && layer.feature.properties.oid_ezor == row.ID) {
                    var color = colorMap[row.NUM - 1] || "#000000";
                    layer.value = row.VALUE;
                    layer.feature.properties.value = row.VALUE;
                    layer.feature.properties.mikra = row.MIKRA;
                    layer.feature.properties.color = color;
                    layer.feature.properties.fillOpacity = 0.5;
                    layer.setStyle({ color: color, fillColor: color, fillOpacity: 0.5 });
                }
            });
        });
    };
    reader.readAsArrayBuffer(file);
}
async function fetchBuildingsData(polygon) {
    var coordinates = polygon.getLatLngs()[0].map(coord => `${coord.lat} ${coord.lng}`).join(" ");
    var query = `
        [out:json];
        (
            way["building"](poly:"${coordinates}");
            node["addr:housenumber"](poly:"${coordinates}");
        );
        out body;`;
    var url = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;
    try {
        var response = await axios.get(url);
        return response.data.elements;
    } catch (error) {
        console.error("砖 注转 转 -Overpass API", error);
        return [];
    }
}

async function downloadBuildingsData() {
    var data = [];
    for (let layer of drawnItems.getLayers()) {
        var buildings = await fetchBuildingsData(layer);
        buildings.forEach(building => {
            if (building.tags) {
                data.push({
ID: layer.feature.properties.id,
"ID ": building.id || " 注",
"专": building.tags["addr:street"] || " 注",
"住驻专": building.tags["addr:housenumber"] || " 注",
"拽 专": building.lat || " 注",
"拽 专": building.lon || " 注"
});

                    }
                });
            }
            if (data.length === 0) {
                alert(" 爪 转  转 驻");
                return;
            }
            var ws = XLSX.utils.json_to_sheet(data);
            var wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "Buildings");
            XLSX.writeFile(wb, "buildings_data.xlsx");
        }
function downloadPolygonsToExcel() {
    var data = [];
    drawnItems.eachLayer(layer => {
        if (layer.feature) {
            var latlngs = layer.getLatLngs()[0].map(coord => `${coord.lat}, ${coord.lng}`).join(" | ");
            data.push({
                ID: layer.feature.properties.oid_ezor,
                爪注: layer.value,
                注专: layer.feature.properties.ms_ezor,
                拽专转: latlngs
            });
        }
    });
    if (data.length === 0) {
        alert(" 驻 专");
        return;
    }
    var ws = XLSX.utils.json_to_sheet(data);
    var wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Polygons");
    XLSX.writeFile(wb, "polygons.xlsx");
}

L.control.BigImage({position: 'topright'}).addTo(map);

    </script>
</body>
</html>

